version "4.0"

class DataLibrary : Thinker
{
    //Level status index corresponds to map number
    Dictionary dic;
    Dictionary monsterParties;
    Dictionary monsterPops;
    
    //Quick, make this a static thinker when we initialize
    DataLibrary Init(void)
	{
		ChangeStatNum(STAT_STATIC);
        dic = Dictionary.Create();
        monsterParties = Dictionary.Create();
        monsterPops = Dictionary.Create();
        
        int lumpindex = Wads.FindLump('MPARTY', 0, 0);
        String lumpdata = Wads.ReadLump(lumpindex);

        Array<String> lines; lumpdata.Split(lines, "\n");
        for (int i = 0; i < lines.Size(); i++)
        {
            String line = lines[i];
            if (line.Length() < 2) { continue; } //In the absence of trim()
            Array<String> lineData; line.Split(lineData, ",");
            String partyName = lineData[0];
            monsterParties.Insert(partyName .. "-Name", lineData[1]);
            for (int t = 2; t < lineData.Size(); t++) {
                if (lineData[t] == "NONE") { continue; }
                monsterParties.Insert(partyName .. "-" .. t-2, lineData[t]);
                
            }
        }
        
        // ---
        
        lumpindex = Wads.FindLump('MPOPUL', 0, 0);
        lumpdata = Wads.ReadLump(lumpindex);
        Array<String> mPops; lumpdata.Split(mPops, "\n");
        for (int i = 0; i < mPops.Size(); i++)
        {
            String line = mPops[i];
            if (line.Length() < 2) { continue; } //In the absence of trim()
            Array<String> lineData; line.Split(lineData, "=");
            String popId = lineData[0];
            monsterPops.Insert(popId, lineData[1]);
        }
        
        // ---
        
        lumpindex = Wads.FindLump('SQUAREDT', 0, 0);
        lumpdata = Wads.ReadLump(lumpindex);
        Array<String> squareData; lumpdata.Split(squareData, "\n");
        for (int i = 0; i < squareData.Size(); i++)
        {
            String line = squareData[i];
            if (line.Length() < 2) { continue; } //In the absence of trim()
            Array<String> lineData; line.Split(lineData, "=");
            String key = lineData[0];
            dic.Insert(key, lineData[1]);
        }
        
		return self;
	}

    static DataLibrary inst(void)
	{
		ThinkerIterator it = ThinkerIterator.Create("DataLibrary", STAT_STATIC);
		let p = DataLibrary(it.Next());
		if (p) return p;
        return new("DataLibrary").Init();
	}
    
    static clearscope DataLibrary GetInstance(void)
    {
		ThinkerIterator it = ThinkerIterator.Create("DataLibrary", STAT_STATIC);
		let p = DataLibrary(it.Next());
		if (p) return p;
        return NULL;
    }
    
    //Static methods for calling from ACS - these will create an instance of the thinker if it doesn't already exist
    static void WriteData(Actor activator, String position, String value) { DataLibrary.inst().dic.Insert(position, value); }
    
    static String ReadData(String position) { return DataLibrary.inst().dic.At(position); }
    static int ReadInt(String position) { return DataLibrary.inst().dic.At(position).ToInt(); }
    static int ReadDouble(String position) { return DataLibrary.inst().dic.At(position).ToDouble(); }
    
    static String ReadMonsterParty(String party, String slot)
    {
        String key = party .. "-" .. slot;
        return DataLibrary.inst().monsterParties.At(key);
    }
    
    static String ChooseMonsterParty(int mapnum, int square) {
    
        //To choose a monster party, get the population ID of this square
        String key = "MP-" .. mapnum .. "-" .. square;
        String popId = DataLibrary.inst().dic.At(key);

        //Ask the monsterpop dictionary which parties correspond to this population ID
        console.printf("Key %s has monster population ID %s", key, popId);
        return ChooseMonsterPartyFromPopulationID(popId);
    }
    
    static String ChooseMonsterPartyFromPopulationID(String popId) {
        //Get the parties that correspond to this monster population
        String monsterPartyString = DataLibrary.inst().monsterPops.At(popId);
        console.printf("Monster parties: %s", monsterPartyString);
        //Now split the string and return a name
        Array<String> monsterParties; monsterPartyString.Split(monsterParties, ",");
        if (monsterParties.Size() == 0) {
            console.printf("WARNING: No monster parties set for population %s", popId);
            DataLibrary.inst().WriteData(null, "NextMonsterParty", "ZombieWeak");
            DataLibrary.inst().WriteData(null, "NextMonsterPartyName", "Nobody really");
            return "ZombieWeak";
        }
        
        String chosenParty = monsterParties[random(0, monsterParties.Size()-1)];
        DataLibrary.inst().WriteData(null, "NextMonsterParty", chosenParty);
        String chosenPartyName = DataLibrary.inst().ReadMonsterParty(chosenParty, "Name");
        chosenPartyName.Replace("_", " ");
        DataLibrary.inst().WriteData(null, "NextMonsterPartyName", chosenPartyName);
        return chosenParty;
    }
    
    static int ReadDangerValue(int mapnum, int square)
    {
        String key = "DN-" .. mapnum .. "-" .. square;
        int value = DataLibrary.inst().dic.At(key).ToInt();
        console.printf("%s %d", key, value);
        return value;
    }
    
    static int LoadMapProperties(Actor activator)
    {
        MapDescriber m; ThinkerIterator it = ThinkerIterator.Create("MapDescriber");
        while (m = MapDescriber(it.Next() ) ) {
            DataLibrary.inst().WriteData(null, "ArenaMap", m.args[1] .. "");
            console.printf("Map describer found, map type is " .. m.args[0]);
            return m.args[0];
        }
        return 0;
    }
}

class LevelHelper : Thinker
{
    const TILE_SIZE = 128;
    
    //Quick, make this a static thinker when we initialize
    LevelHelper Init(void)
	{
		ChangeStatNum(STAT_STATIC);
		return self;
	}

    static bool IsPointInLevel(Actor activator, int x, int y, int z)
    {
        console.printf("Checking target point: %f %f %f", x >> 16, y >> 16, z >> 16);
        Vector3 a = (x >> 16, y >> 16, z >> 16);
        bool isPoint = level.IsPointInLevel(a);
        return(isPoint);
    }
    
    static int getSquareFromPosition(float x, float y) {
        int squareNum = 10000;
        squareNum += (int) (x / TILE_SIZE);
        squareNum += (int) (y*100 / TILE_SIZE);
        return squareNum;
    }

    static int, int getPositionFromSquare(int squareNum) {
        squareNum -= 10000;
        int x = ((squareNum % 100) * TILE_SIZE);
        squareNum /= 100;
        int y = ((squareNum % 100) * TILE_SIZE);
        return x, y;
    }
    
    static int HandleMapExit(Actor activator)
    {
        ExitSpot spot; ThinkerIterator it = ThinkerIterator.Create("ExitSpot");
        while (spot = ExitSpot(it.Next() ) ) {
            if (spot.pos.x == activator.pos.x && spot.pos.y == activator.pos.y) {
                int squareNum = spot.args[1];
                double myangle = spot.angle * 182; //This converts from degrees to fixed-point angle
                console.printf("Translated angle is %f", myangle);
                DataLibrary.inst().WriteData(null, "FieldSquare", squareNum .. "");
                DataLibrary.inst().WriteData(null, "FieldAngle",  myangle .. "");
                return spot.args[0]; //This is the mapnum for the exit's target
            }
        }
        return 0;
    }
    
    static int IsOnWetFloor(Actor actor) {
        String textureName = GetActorFloorTexture(actor);
        String wetFloors = "F_WATER1, NUKAGE1";
        if (wetFloors.indexOf(textureName) > -1) {
            return 1;
        }
        return 0;
    }
    
    static int IsOnDamagingFloor(Actor actor) {
        String textureName = GetActorFloorTexture(actor);
        String damagingFloors = "NUKAGE1";
        if (damagingFloors.indexOf(textureName) > -1) {
            return 1;
        }
        return 0;
    }
    
    static String GetActorFloorTexture(Actor actor)
    {
        Sector sec = actor.CurSector;
        TextureID tex = sec.GetTexture(0);
        String name = TexMan.getName(tex);
        return name;
    }
}

class FOE : FloatingSkull
{

    default {
        Health 50;
        Radius 20;
        Height 60;
        +FLOATBOB;
        +NOGRAVITY;
        //$Arg0 Monster Population
        //$Arg0Tooltip The ID of the monster population that this FOE will trigger.
    }
    States {
        Spawn:
            PAIN ABC 15;
            Loop;
        Destroy:
            PAIN H 8 A_PlaySound("po/foe/death");
            PAIN IJKLM 8;
            Stop;
    }

    bool overlapsPlayer(Actor other) {
        return isAtPosition(other.pos.x, other.pos.y);
    }
    
    bool isAtPosition(float x, float y) {
        return (pos.x == x && pos.y == y);
    }
    
    int getMonsterPop() {
        return args[0];
    }
}

class MonsterTurner : MapSpot
{
    default {
        //$Sprite TURNA0
    }
}

class FOESpot : MapSpot
{
    default {
        //$Sprite PAINA1
    }
}

class ExitSpot : MapSpot
{
    default {
        //$Sprite SOULA0
        //$Arg0 Go To Map
        //$Arg0Tooltip The mapnum of this exit's target
        //$Arg1 Go To Square
        //$Arg1Tooltip The square number of this exit's target
    }
}

class MapDescriber : MapSpot
{
    default {
        //$Sprite MEGAA0
        //$Arg0 Map Type
        //$Arg0Tooltip 0 for no special, 1 to run RPG movement, 2 for arena
        //$Arg1 Arena Mapnum
        //$Arg1Tooltip Mapnum to use for arenas on this level
    }
}

class FOEHelper : Thinker
{
    
    //Quick, make this a static thinker when we initialize
    FOEHelper Init(void)
	{
		ChangeStatNum(STAT_STATIC);
		return self;
	}
    
    static int moveFOEs(Actor activator)
    {
        int foeMonsterPop = 0;
        FOE foe; ThinkerIterator foeIterator = ThinkerIterator.Create("FOE");
        while (foe = FOE(foeIterator.Next() ) ) {
            
            //Move the monster one grid space according to its current angle
            vector3 mypos = foe.Pos;
            vector3 oldpos = mypos;
            int myangle = (int) (foe.angle);
            int deltaX = 0;
            int deltaY = 0;
            switch (myangle) {
                case 0: deltaX = 128; break;
                case 90: deltaY = 128; break;
                case 180: deltaX = -128; break;
                case 270: deltaY = -128; break;
            }
            mypos.x += deltaX;
            mypos.y += deltaY;
            foe.SetOrigin(mypos, true);
            
            if (foe.overlapsPlayer(activator)) {
                foe.SetOrigin(oldpos, false);
                int squareNum = LevelHelper.getSquareFromPosition(oldpos.x, oldpos.y);
                DataLibrary.inst().WriteData(null, "CurrentFOESquare", squareNum .. "");
                foeMonsterPop = foe.getMonsterPop();
            }
            
            //If they've hit a turner, set their angle to match that turner
            MonsterTurner turner; ThinkerIterator turnIterator = ThinkerIterator.Create("MonsterTurner");
            while (turner = MonsterTurner(turnIterator.next())) {
                vector3 turnpos = turner.Pos;
                if (turnpos.x == mypos.x && turnpos.y == mypos.y) {
                    foe.angle = turner.angle;
                }
            }
        }
        
        return foeMonsterPop; //This will be positive if a FOE has hit the player
    }
    
    static int PlayerOverlapsAnyFOE(Actor activator)
    {
        FOE foe; ThinkerIterator foeIterator = ThinkerIterator.Create("FOE");
        while (foe = FOE(foeIterator.Next() ) ) {
            if (foe.overlapsPlayer(activator)) {
                int squareNum = LevelHelper.getSquareFromPosition(foe.pos.x, foe.pos.y);
                DataLibrary.inst().WriteData(null, "CurrentFOESquare", squareNum .. "");
                return foe.getMonsterPop();
            }
        }
        return 0;
    }
    
    static void DestroyCurrentFOE()
    {
        console.printf("Attempting to destroy FOE");
        String squareNum = DataLibrary.inst().ReadData("CurrentFOESquare");
        console.printf("Square num for FOE: %s", squareNum);
        if (!squareNum) {
            return;
        }
        //Got a squarenum! Let's translate it
        int x;
        int y;
        [x, y] = LevelHelper.getPositionFromSquare(squareNum.ToInt());
        FOE foe; ThinkerIterator foeIterator = ThinkerIterator.Create("FOE");
        while (foe = FOE(foeIterator.Next() ) ) {
            console.printf("Looking for: %d %d", x, y);
            if (foe.isAtPosition(x, y)) {
                DataLibrary.inst().WriteData(null, "CurrentFOESquare", "");
                foe.SetState(foe.FindState("Destroy"));
                console.printf("Destroyed FOE");
                break;
            }
        }
    }
}